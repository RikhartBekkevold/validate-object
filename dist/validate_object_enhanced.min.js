/* validate_object_enhanced.js - copyright Rikhart Bekkevold. MIT license. Version 1.0.0. */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).validate_object_enhanced=t()}(this,(function(){"use strict";var e=Array.isArray,t=Number.isNaN;var r=Object.prototype.toString;function n(e){return Number.isInteger(e)}var i={isPlainObject:function(e){return"object"==typeof e&&!Array.isArray(e)&&null!==e},isFunction:function(e){return"function"==typeof e},isObjectOrFn:function(e){return"object"==typeof e||"function"==typeof e},isBoolean:function(e){return"boolean"==typeof e},isSymbol:function(e){return"symbol"==typeof e},isNumber:function(e){return"number"==typeof e},isValidNumber:function(e){return Number.isFinite(e)},isInfinite:function(e){return e===1/0||e===-1/0},isString:function(e,t){return t?"string"==typeof e&&function(e,t){return r.call(e)==="[object "+t+"]"}(e,"String"):"string"==typeof e},isBigInt:function(e){return"bigint"==typeof val},isInt:n,isFloat:function(e){return!n(e)},isArray:e,isNaN:t,isNotDefined:function(e){return!function(e){return null!==e||"undefined"!==e}(e)},isFalsy:function(e){return!1==!!e},isSet:function(e){return e instanceof Set}};const{isFunction:o,isPlainObject:s,isNumber:a,isString:u,isValidNumber:f,isInt:c,isFloat:l,isBigInt:y,isInfinite:p,isBoolean:b,isSymbol:d,isObjectOrFn:g,isArray:h,isNaN:m,isDefined:v,isNotDefined:w,isFalsy:O,isTruthy:j,isSet:S}=i;var k=new Map([["function",o],["string",u],["number",a],["num",a],["validnumber",f],["validnum",f],["integer",c],["int",c],["float",l],["bigint",y],["nan",m],["infinity",p],["infinite",p],["boolean",b],["bool",b],["symbol",d],["object",s],["array",h],["null",()=>null===val],["undefined",()=>void 0===val],["defined",v],["not defined",w],["bottomtype",w],["empty",()=>!v],["falsy",O],["truthy",j],["set",S]]);Map.prototype.toString=function(e,t){var r=e?"\n":", ",n="";for(var i of(console.log(Array.from(this.keys())),this.values()))n+="'"+i+"'"+r;return e?n:n.slice(0,n.length-2)};var N=k,E=Object.prototype.hasOwnProperty;function T(e){return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))}var A={getAllOwnKeys:T,hasOwn:function(e,t){return E.call(e,t)},hasOwnStringedEnumKeys:function(e,t){for(var r of t=T(e))if(!t.includes(r))return!1;return!0},hasOwnExactStringedEnumKeys:function(e,t){var r=T(e);if(r.length!==t.length)return!1;for(var n of r)if(!t.includes(n))return!1;return!0}};var F={hasProto:function(e){return!!Object.getPrototypeOf(e)},protoIs:function(e,t){return Object.getPrototypeOf(e)===t}},I={},P=Object.prototype.toString;I.normalizeString=function(e){return e.toLowerCase()},I.capitalize=function(e){return e.charAt(0).toUpperCase()+e.slice(1)},I.getType=function(e){return P.call(e).slice(8,-1).toLowerCase()};const{hasOwn:x}=A;var K={validateDescriptor:function(e,t,r){return e=Object.getOwnPropertyDescriptor(e,t),!(x(r,"configurable")&&e.configurable!==r.configurable||x(r,"enumerable")&&e.enumerable!==r.enumerable||x(r,"writable")&&e.writable!==r.writable)}};const{hasOwn:z}=A;var D={mergeKeyOverlap:function(e,t){for(var r in e)z(e,r)&&z(t,r)&&(e[r]=t[r]);return e}},M={config:{followNestedObjects:!0}};const{isString:V}=i;var B={isValidObjectMeta:function(e){return V(e)&&"sealed"===e||"frozen"===e||"extensible"===e}};const C=N,{isPlainObject:R,isString:L,isArray:_,isObjectOrFn:U,isFunction:q}=i,{hasOwn:G,hasOwnStringedEnumKeys:H,hasOwnExactStringedEnumKeys:J}=A,{protoIs:Q,hasProto:W}=F,{normalizeString:X,capitalize:Y,getType:Z}=I,{validateDescriptor:$}=K,{mergeKeyOverlap:ee}=D,{config:te}=M,{isValidObjectMeta:re}=B;function ne(e,t,r){return G(r,"type")&&!oe(e[t],r.type)||G(r,"meta")&&!$(e,t,r.meta)||G(r,"value")&&(n=e[t],i=r.value,!(q(i)?i(n):n===i));var n,i}function ie(e,t){return G(e,t)}function oe(e,t){if(q(t))return t(e);if(L(t)){t=X(t);if(C.has(t))return C.get(t)(e);throw new TypeError("Invalid string value '"+t+"'. Allowed types (upper or lowercase):\n"+C.toString(!0,!0)+"\n")}if(_(t)){for(var[r,n]of t.entries())if(t[r]=X(n),!C.has(t[r]))throw new TypeError("Invalid string value '"+t[r]+"'. Allowed types (upper or lowercase):\n"+C.toString()+"\n");for(var n of t)if(C.has(n)&&C.get(n)(e))return!0;return!1}throw new TypeError("Schema 'type' properties needs to be either function or string. Received "+Z(t)+".")}function se(e,t){return ee(e,R(t)?t:{})}var ae={validateObject:function(e,t,r){if(!R(t))throw new TypeError("The 'schema' argument needs to be an object, not "+t+" ("+Z(t)+").");return!!R(e)&&(r&&se(te,r),function e(t,r,n){if(!G(r,"keys"))throw new Error("Missing 'keys' property for object in schema object.");if(R(r.keys))for(var n in r.keys){if(!ie(t,n))return!1;if(R(t[n])&&te.followNestedObjects){if(!e(t[n],r.keys[n]))return!1}else if(R(r.keys[n])){if(ne(t,n,r.keys[n]))return!1}else if(L(r.keys[n])){if(!oe(t[n],r.keys[n]))return!1}else{if(!_(r.keys[n]))throw new TypeError("The schema properties in the 'keys' array/object needs to be either object or string. Recieved "+r.keys[n]+".");var i=!1;for(var o of r.keys[n])if(oe(t[n],o)){i=!0;break}if(!i)return!1}}else{if(!_(r.keys))throw new Error("Schema 'keys' property needs to be either array or object. Recieved "+r.keys+" ("+Z(r.keys)+").");if(r.exact){if(!J(t,r.keys))return!1}else if(!H(t,r.keys))return!1}return!!function(e,t){if(U(t.proto)&&!Q(e,t.proto))return!1;if(!0===t.proto&&!W(e))return!1;return!0}(t,r)&&!!function(e,t){if(t.meta){if(!re(t.meta))throw new TypeError("The meta property only accepts the values: 'frozen', 'sealed' or 'extensible' when used to validate an object.");if(!Object["is"+Y(t.meta)](e))return!1}return!0}(t,r)}(e,t))},setOptions:se,addAlias:function(e,t){return!(!L(e)||!L(t)||C.has(t))&&(C.set(t,C.get(e)),!0)},addValidator:function(e,t){return!(!L(e)||!q(t)||C.has(e))&&(C.set(e,t),!0)}};return ae}));
